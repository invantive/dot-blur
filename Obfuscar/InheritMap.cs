#region Copyright (c) 2007 Ryan Williams <drcforbin@gmail.com>

// <copyright>
// Copyright (c) 2007 Ryan Williams <drcforbin@gmail.com>
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
// </copyright>

#endregion

using Mono.Cecil;
using System.Collections.Generic;
using System.Text;

namespace Obfuscar
{
    internal class InheritMap
    {
        private readonly Project project;

        //
        // Map method to group.
        //
        private readonly Dictionary<MethodKey, MethodGroup> methodGroups = new Dictionary<MethodKey, MethodGroup>();

        private readonly Dictionary<TypeKey, TypeKey[]> baseTypes = new Dictionary<TypeKey, TypeKey[]>();

        public InheritMap(Project project)
        {
            this.project = project;

            //
            // Cache for assemblies not in the project.
            //
            project.Cache = new AssemblyCache(project);

            foreach (AssemblyInfo info in project.AssemblyList)
            {
                foreach (TypeDefinition type in info.GetAllTypeDefinitions())
                {
                    if (type.FullName == Obfuscator.AutoGeneratedModuleName)
                    {
                        continue;
                    }

                    TypeKey typeKey = new TypeKey(type);

                    this.baseTypes[typeKey] = this.GetBaseTypes(type);

                    int i = 0;
                    int j;

                    MethodKey[] methods = this.GetVirtualMethods(project.Cache, type);

                    while (i < methods.Length)
                    {
                        MethodKey left = methods[i];

                        if (!this.methodGroups.TryGetValue(left, out MethodGroup? group))
                        {
                            group = null;
                        }

                        for (j = i + 1; j < methods.Length; j++)
                        {
                            MethodKey right = methods[j];

                            if (!MethodsMatch(left, right))
                            {
                                continue;
                            }

                            //
                            // Found an override.
                            //
                            // See if either method is already in a group.
                            //
                            if (group != null)
                            {
                                group = this.AddToGroup(group, right);
                            }
                            else if (this.methodGroups.TryGetValue(right, out group))
                            {
                                group = this.AddToGroup(group, left);
                            }
                            else
                            {
                                group = new MethodGroup();

                                group = this.AddToGroup(group, left);
                                group = this.AddToGroup(group, right);
                            }
                            //
                            // If the group isn't already external, see if it should be.
                            //
                            if (group == null)
                            {
                                throw new ObfuscarException(MessageCodes.dbr033, "Missing group.");
                            }

                            if (!group.External && !project.Contains(right.TypeKey))
                            {
                                group.External = true;
                            }
                        }

                        //
                        // If the group isn't already external, see if it should be.
                        //
                        if (group != null && !group.External && !project.Contains(left.TypeKey))
                        {
                            group.External = true;
                        }

                        //
                        // Move on to the next thing that doesn't match.
                        //
                        i++;
                    }
                }
            }
        }

        static bool MethodsMatch(MethodKey left, MethodKey right)
        {
            return MethodKey.MethodMatch(left.Method, right.Method) || MethodKey.MethodMatch(right.Method, left.Method);
        }

        public static void GetBaseTypes(Project project, HashSet<TypeKey> baseTypes, TypeDefinition type)
        {
            //
            // Check the interfaces.
            //
            foreach (InterfaceImplementation ifaceRef in type.Interfaces)
            {
                TypeDefinition? iface = project.GetTypeDefinition(ifaceRef.InterfaceType);

                if (iface != null)
                {
                    GetBaseTypes(project, baseTypes, iface);
                    baseTypes.Add(new TypeKey(iface));
                }
            }

            //
            // Check the base type unless it isn't in the project, or we don't have one.
            //
            TypeDefinition? baseType = project.GetTypeDefinition(type.BaseType);
            if (baseType != null && baseType.FullName != "System.Object")
            {
                GetBaseTypes(project, baseTypes, baseType);
                baseTypes.Add(new TypeKey(baseType));
            }
        }

        private TypeKey[] GetBaseTypes(TypeDefinition type)
        {
            HashSet<TypeKey> baseTypes = new HashSet<TypeKey>();
            GetBaseTypes(this.project, baseTypes, type);
            return new List<TypeKey>(baseTypes).ToArray();
        }

        private void GetVirtualMethods(AssemblyCache cache, HashSet<MethodKey> methods, TypeDefinition type)
        {
            //
            // Check the interfaces.
            //
            foreach (InterfaceImplementation ifaceRef in type.Interfaces)
            {
                TypeDefinition? iface = this.project.GetTypeDefinition(ifaceRef.InterfaceType);

                //
                // If it's not in the project, try to get it via the cache.
                //
                if (iface == null)
                {
                    iface = cache.GetTypeDefinition(ifaceRef.InterfaceType);
                }

                //
                // Search interface.
                //
                if (iface != null)
                {
                    this.GetVirtualMethods(cache, methods, iface);
                }
            }

            //
            // Check the base type unless it isn't in the project, or we don't have one.
            //
            TypeDefinition? baseType = this.project.GetTypeDefinition(type.BaseType);

            //
            // If it's not in the project, try to get it via the cache.
            //
            if (baseType == null)
            {
                baseType = cache.GetTypeDefinition(type.BaseType);
            }

            //
            // Search base.
            //
            if (baseType != null)
            {
                this.GetVirtualMethods(cache, methods, baseType);
            }

            foreach (MethodDefinition method in type.Methods)
            {
                if (method.IsVirtual)
                {
                    methods.Add(new MethodKey(method));
                }
            }

            foreach (PropertyDefinition property in type.Properties)
            {
                if (property.GetMethod != null && property.GetMethod.IsVirtual)
                {
                    methods.Add(new MethodKey(property.GetMethod));
                }

                if (property.SetMethod != null && property.SetMethod.IsVirtual)
                {
                    methods.Add(new MethodKey(property.SetMethod));
                }
            }

            foreach (EventDefinition @event in type.Events)
            {
                if (@event.AddMethod != null && @event.AddMethod.IsVirtual)
                {
                    methods.Add(new MethodKey(@event.AddMethod));
                }

                if (@event.RemoveMethod != null && @event.RemoveMethod.IsVirtual)
                {
                    methods.Add(new MethodKey(@event.RemoveMethod));
                }
            }
        }

        MethodKey[] GetVirtualMethods(AssemblyCache cache, TypeDefinition type)
        {
            HashSet<MethodKey> methods = new HashSet<MethodKey>();
            this.GetVirtualMethods(cache, methods, type);
            return new List<MethodKey>(methods).ToArray();
        }

        MethodGroup AddToGroup(MethodGroup group, MethodKey methodKey)
        {
            //
            // Add the method to the group.
            //
            group.Methods.Add(methodKey);

            //
            // Point the method at the group.
            //
            if (this.methodGroups.TryGetValue(methodKey, out MethodGroup? group2) && group2 != group)
            {
                //
                // Two unrelated groups come together; merge them.
                //
                if (group.Methods.Count > group2.Methods.Count)
                {
                    group.Name = group.Name ?? group2.Name;
                    group.External = group.External | group2.External;

                    foreach (MethodKey mk in group2.Methods)
                    {
                        this.methodGroups[mk] = group;
                        group.Methods.Add(mk);
                    }

                    return group;
                }
                else
                {
                    group2.Name = group2.Name ?? group.Name;
                    group2.External = group2.External | group.External;

                    foreach (MethodKey mk in group.Methods)
                    {
                        this.methodGroups[mk] = group2;
                        group2.Methods.Add(mk);
                    }

                    return group2;
                }
            }

            this.methodGroups[methodKey] = group;

            return group;
        }

        public MethodGroup? GetMethodGroup(MethodKey methodKey)
        {
            if (this.methodGroups.TryGetValue(methodKey, out MethodGroup? group))
            {
                return group;
            }
            else
            {
                return null;
            }
        }

        public bool Inherits(TypeDefinition type, string interfaceFullName)
        {
            if (type.FullName == interfaceFullName)
            {
                return true;
            }

            if (type.BaseType != null)
            {
                TypeDefinition? typeDef = this.project.Cache.GetTypeDefinition(type.BaseType);

                if (typeDef != null)
                {
                    return this.Inherits(typeDef, interfaceFullName);
                }
                else
                {
                    return false;
                }
            }

            return false;
        }

        public TypeKey[] GetBaseTypes(TypeKey typeKey)
        {
            return this.baseTypes[typeKey];
        }
    }
}
