#region Copyright (c) 2007 Ryan Williams <drcforbin@gmail.com>

// <copyright>
// Copyright (c) 2007 Ryan Williams <drcforbin@gmail.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
// </copyright>

#endregion

using ILSpy.BamlDecompiler.Baml;
using Mono.Cecil;
using Mono.Cecil.Cil;
using Mono.Cecil.Rocks;
using Obfuscar.Helpers;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using System.Xml.Linq;

namespace Obfuscar
{
    /// <summary>
    /// Obfuscator.
    /// </summary>
    [SuppressMessage("StyleCop.CSharp.SpacingRules", "SA1027:TabsMustNotBeUsed", Justification =
        "Reviewed. Suppression is OK here.")]
    public class Obfuscator
    {
        /// <summary>
        /// Module name for auto-generated global module.
        /// </summary>
        public const string AutoGeneratedModuleName = "<Module>";

        /// <summary>
        /// Version of Obfuscar used as baseline for this DotBlur version.
        /// </summary>
        public const string OriginalObfuscarBaseVersion = "2.2.40";

        /// <summary>
        /// Patch level within version of Obfuscar based upon.
        /// </summary>
        public const string DotBlurPatchLevel = "8";

        /// <summary>
        /// Full version.
        /// </summary>
        public const string FullVersion = OriginalObfuscarBaseVersion + "." + DotBlurPatchLevel;

        // Unique names for type and members
        private int _uniqueTypeNameIndex;

        private int _uniqueMemberNameIndex;

        /// <summary>
        /// Creates an obfuscator initialized from a project filename/path.
        /// </summary>
        /// <param name="projectFileNamePath">Path to project file.</param>
        [SuppressMessage("StyleCop.CSharp.SpacingRules", "SA1027:TabsMustNotBeUsed", Justification =
            "Reviewed. Suppression is OK here.")]
        public Obfuscator(string projectFileNamePath)
        {
            this.Mapping = new ObfuscationMap();

            try
            {
                XDocument document = XDocument.Load(projectFileNamePath);
                this.LoadFromReader(document, projectFileNamePath);
            }
            catch (IOException e)
            {
                throw new ObfuscarException(MessageCodes.dbr014, string.Format(Translations.GetTranslationOfKey(TranslationKeys.db_dbr014_msg_par1), projectFileNamePath), innerException: e);
            }
            catch (System.Xml.XmlException e)
            {
                throw new ObfuscarException(MessageCodes.dbr018, string.Format(Translations.GetTranslationOfKey(TranslationKeys.db_dbr018_msg_par1), projectFileNamePath), innerException: e);
            }
        }

        /// <summary>
        /// Creates an obfuscator initialized from a project file.
        /// </summary>
        /// <param name="reader">The reader.</param>
        private Obfuscator(XDocument reader)
        {
            this.Mapping = new ObfuscationMap();
            this.LoadFromReader(reader, null);
        }

        /// <summary>
        /// Run rules.
        /// </summary>
        /// <param name="hideStrings">Whether to hide strings.</param>
        public void RunRules(bool hideStrings = true)
        {
            //
            // The SemanticAttributes of MethodDefinitions have to be loaded before any fields,properties or events are removed
            //
            this.LoadMethodSemantics();

            if (hideStrings)
            {
                Log.OutputLine(MessageCodes.dbr052, Translations.GetTranslationOfKey(TranslationKeys.db_hide_strings));
                this.HideStrings();
            }
            else
            {
                Log.OutputLine(MessageCodes.dbr053, Translations.GetTranslationOfKey(TranslationKeys.db_not_hide_strings));
            }

            this.RenameFields();
            this.RenameParameters();
            this.RenameProperties();
            this.RenameEvents();
            this.RenameMethods();
            this.RenameTypes();
            this.PostProcessing();
            this.SaveAssemblies();
            this.SaveMapping();
        }

        /// <summary>
        /// Create obfuscator from XML.
        /// </summary>
        /// <param name="xml">The XML to read.</param>
        /// <returns>A new <see cref="Obfuscator">Obfuscator</see> instance.</returns>
        public static Obfuscator CreateFromXml(string xml)
        {
            XDocument document = XDocument.Load(new StringReader(xml));

            return new Obfuscator(document);
        }

        internal Project Project { get; private set; }

        [MemberNotNull(nameof(Project))]
        private void LoadFromReader(XDocument reader, string? projectFileDirectory)
        {
            this.Project = Project.FromXml(reader, projectFileDirectory);

            //
            // Make sure everything looks good.
            //
            this.Project.CheckSettings();

            NameMaker.DetermineChars(this.Project.Settings);

            Log.OutputLine(MessageCodes.dbr116, Translations.GetTranslationOfKey(TranslationKeys.db_dbr116_msg));

            if (this.Project.ExtraPaths?.Any() ?? false)
            {
                Log.OutputLine(MessageCodes.dbr059, Translations.GetTranslationOfKey(TranslationKeys.db_dbr059_msg));

                foreach (string extraPath in this.Project.ExtraPaths)
                {
                    Log.OutputLine(MessageCodes.dbr058, extraPath + ", ");
                }
            }
            else
            {
                Log.OutputLine(MessageCodes.dbr154, Translations.GetTranslationOfKey(TranslationKeys.db_dbr154_msg));
            }

            Log.OutputLine(MessageCodes.dbr060, null);

            this.Project.LoadAssemblies();
        }

        /// <summary>
        /// Saves changes made to assemblies to the output path.
        /// </summary>
        private void SaveAssemblies(bool throwException = true)
        {
            string outPath = this.Project.Settings.OutPath;

            Log.OutputLine(MessageCodes.dbr056, string.Format(Translations.GetTranslationOfKey(TranslationKeys.db_dbr056_msg_par1), outPath));

            //
            // Copy excluded assemblies.
            //
            foreach (AssemblyInfo copyInfo in this.Project.CopyAssemblyList)
            {
                string? fileName = Path.GetFileName(copyInfo.FileName);

                if (string.IsNullOrEmpty(fileName))
                {
                    throw new ObfuscarException(MessageCodes.dbr141, Translations.GetTranslationOfKey(TranslationKeys.db_dbr141_msg));
                }

                string outName = Path.Combine(outPath, fileName);
                copyInfo.Definition.Write(outName);
            }

            //
            // Cecil does not properly update the name cache, so force that.
            //
            foreach (AssemblyInfo info in this.Project.AssemblyList)
            {
                if (info.Definition != null)
                {
                    Mono.Collections.Generic.Collection<TypeDefinition> types = info.Definition.MainModule.Types;

                    for (int i = 0; i < types.Count; i++)
                    {
                        types[i] = types[i];
                    }
                }
            }

            int assemblyCount = this.Project.AssemblyList.Count;

            Log.OutputLine(MessageCodes.dbr122, string.Format(Translations.GetTranslationOfKey(TranslationKeys.db_dbr122_msg_par1), assemblyCount));

            //
            // Save the modified assemblies.
            //
            foreach (AssemblyInfo info in this.Project.AssemblyList)
            {
                if (info.Definition == null)
                {
                    throw new ObfuscarException(MessageCodes.dbr026, Translations.GetTranslationOfKey(TranslationKeys.db_definition_missing));
                }

                string? fileName = Path.GetFileName(info.FileName);

                try
                {
                    if (string.IsNullOrEmpty(fileName))
                    {
                        throw new ObfuscarException(MessageCodes.dbr142, Translations.GetTranslationOfKey(TranslationKeys.db_filename_missing));
                    }

                    string outName = Path.Combine(outPath, fileName);

                    WriterParameters parameters = new WriterParameters();

                    if (this.Project.Settings.RegenerateDebugInfo)
                    {
                        if (this.IsOnWindows)
                        {
                            parameters.SymbolWriterProvider = new PortablePdbWriterProvider();
                        }
                        else
                        {
                            parameters.SymbolWriterProvider = new Mono.Cecil.Pdb.PdbWriterProvider();
                        }
                    }

                    if (info.Definition.Name.HasPublicKey)
                    {
                        //
                        // Source assembly was strong-name signed.
                        //
                        string? keyFileName = this.Project.Settings.KeyFile;
                        string? keyFilePassword = this.Project.Settings.KeyFilePassword;
                        string? keyContainerName = this.Project.Settings.KeyContainer;
                        string? signingFileDigestAlgorithm = this.Project.Settings.SigningFileDigestAlgorithm;
                        string? signingTimeStampServerUrl = this.Project.Settings.SigningTimeStampServerUrl;

                        byte[]? keyPair = this.Project.KeyPair;

                        if (keyPair != null)
                        {
                            try
                            {
                                parameters.StrongNameKeyBlob = keyPair;

                                info.Definition.Write(outName, parameters);
                                info.OutputFileName = outName;

                                Log.OutputLine(MessageCodes.dbr120, string.Format(Translations.GetTranslationOfKey(TranslationKeys.db_dbr120_msg_par1), fileName, outName));
                            }
                            catch (Exception ex)
                            {
                                parameters.StrongNameKeyBlob = null;

                                if (info.Definition.MainModule.Attributes.HasFlag(ModuleAttributes.StrongNameSigned))
                                {
                                    info.Definition.MainModule.Attributes ^= ModuleAttributes.StrongNameSigned;
                                }

                                //
                                // Delay sign.
                                //
                                info.Definition.Name.PublicKey = keyPair;
                                info.Definition.Write(outName, parameters);
                                info.OutputFileName = outName;

                                Log.OutputLine(MessageCodes.dbr117, string.Format(Translations.GetTranslationOfKey(TranslationKeys.db_dbr117_msg_par1), fileName, outName, ex));
                            }
                        }
                        else if (!string.IsNullOrEmpty(keyContainerName))
                        {
                            //
                            // Config file contains key container name.
                            //
                            info.Definition.Write(outName, parameters);

                            MsNetSigner.StrongNameSignAssemblyFromKeyContainer(outName, keyContainerName);

                            Log.OutputLine(MessageCodes.dbr118, string.Format(Translations.GetTranslationOfKey(TranslationKeys.db_dbr118_msg_par1), fileName, outName, keyContainerName));
                        }
                        else if (!info.Definition.MainModule.Attributes.HasFlag(ModuleAttributes.StrongNameSigned))
                        {
                            //
                            // When an assembly is "delay signed" and no KeyFile or KeyContainer properties were provided,
                            // keep the obfuscated assembly "delay signed" too.
                            //
                            info.Definition.Write(outName, parameters);
                            info.OutputFileName = outName;

                            Log.OutputLine(MessageCodes.dbr119, string.Format(Translations.GetTranslationOfKey(TranslationKeys.db_dbr119_msg_par1), fileName, outName));
                        }
                        else
                        {
                            throw new ObfuscarException
                            ( MessageCodes.dbr015
                            , string.Format(Translations.GetTranslationOfKey(TranslationKeys.db_dbr015_msg_par1), info.Name)
                            , Translations.GetTranslationOfKey(TranslationKeys.db_dbr015_msg)
                            );
                        }

                        if (this.Project.Settings.SignAssembly)
                        {
                            string? signToolExePath = this.DetermineSignToolExePath();

                            if (string.IsNullOrEmpty(signToolExePath))
                            {
                                throw new ObfuscarException(MessageCodes.dbr040, Translations.GetTranslationOfKey(TranslationKeys.db_dbr040_msg));
                            }

                            if (!File.Exists(signToolExePath))
                            {
                                throw new ObfuscarException(MessageCodes.dbr041, string.Format(Translations.GetTranslationOfKey(TranslationKeys.db_dbr041_msg_par1), signToolExePath));
                            }

                            if (string.IsNullOrEmpty(keyFileName))
                            {
                                throw new ObfuscarException(MessageCodes.dbr044, Translations.GetTranslationOfKey(TranslationKeys.db_dbr044_msg));
                            }

                            if (!(Path.GetExtension(keyFileName)?.Equals(".pfx", StringComparison.InvariantCultureIgnoreCase) ?? false))
                            {
                                throw new ObfuscarException(MessageCodes.dbr045, string.Format(Translations.GetTranslationOfKey(TranslationKeys.db_dbr045_msg_par1), keyFileName));
                            }

                            if (string.IsNullOrEmpty(signingFileDigestAlgorithm))
                            {
                                signingFileDigestAlgorithm = SignToolFileDigestAlgorithms.SHA256;
                            }

                            if (string.IsNullOrEmpty(signingTimeStampServerUrl))
                            {
                                signingTimeStampServerUrl = "http://timestamp.digicert.com";
                            }

                            string signToolArguments = $"sign /f \"{keyFileName}\" /p \"{keyFilePassword}\" /fd {signingFileDigestAlgorithm} /t {signingTimeStampServerUrl} \"{outName}\"";

                            Log.OutputLine(MessageCodes.dbr113, string.Format(Translations.GetTranslationOfKey(TranslationKeys.db_dbr113_msg_par1), fileName, signToolExePath, signToolArguments));

                            ProcessStartInfo psi = new ProcessStartInfo(signToolExePath, signToolArguments)
                                                        { UseShellExecute = false
                                                        , RedirectStandardOutput = true
                                                        , RedirectStandardError = true
                                                        , CreateNoWindow = true
                                                        };

                            Process? signProcess = Process.Start(psi);

                            if (signProcess == null)
                            {
                                throw new ObfuscarException(MessageCodes.dbr042, Translations.GetTranslationOfKey(TranslationKeys.db_dbr042_msg));
                            }

                            bool nonEmptyLineSeen;

                            //
                            // Print stdout without leading empty lines.
                            //
                            nonEmptyLineSeen = false;
                            while (!signProcess.StandardOutput.EndOfStream)
                            {
                                string? line = signProcess.StandardOutput.ReadLine();

                                if (!string.IsNullOrEmpty(line))
                                {
                                    nonEmptyLineSeen = true;
                                }

                                if (nonEmptyLineSeen)
                                {
                                    Log.OutputLine(MessageCodes.dbr153, string.Format(Translations.GetTranslationOfKey(TranslationKeys.db_dbr153_msg_par1), line));
                                }
                            }

                            //
                            // Print stderr without leading empty lines.
                            //
                            nonEmptyLineSeen = false;
                            while (!signProcess.StandardError.EndOfStream)
                            {
                                string? line = signProcess.StandardError.ReadLine();

                                if (!string.IsNullOrEmpty(line))
                                {
                                    nonEmptyLineSeen = true;
                                }

                                if (nonEmptyLineSeen)
                                {
                                    Log.OutputLine(MessageCodes.dbr125, string.Format(Translations.GetTranslationOfKey(TranslationKeys.db_dbr125_msg_par1), line));
                                }
                            }

                            const int SignTimeOutMs = 60_000;

                            if (!signProcess.WaitForExit(SignTimeOutMs))
                            {
                                throw new ObfuscarException(MessageCodes.dbr043, string.Format(Translations.GetTranslationOfKey(TranslationKeys.db_dbr043_msg_par1), SignTimeOutMs));
                            }

                            int exitCode = signProcess.ExitCode;

                            if (exitCode == 0)
                            {
                                Log.OutputLine(MessageCodes.dbr123, string.Format(Translations.GetTranslationOfKey(TranslationKeys.db_dbr123_msg_par1), fileName));
                            }
                            else
                            {
                                throw new ObfuscarException(MessageCodes.dbr145, string.Format(Translations.GetTranslationOfKey(TranslationKeys.db_dbr145_msg_par1), fileName, exitCode));
                            }
                        }
                    }
                    else
                    {
                        Log.OutputLine(MessageCodes.dbr124, string.Format(Translations.GetTranslationOfKey(TranslationKeys.db_dbr124_msg_par1), fileName));

                        info.Definition.Write(outName, parameters);
                        info.OutputFileName = outName;
                    }
                }
                catch (Exception e)
                {
                    if (throwException)
                    {
                        throw;
                    }

                    Log.OutputLine(MessageCodes.dbr061, string.Format(Translations.GetTranslationOfKey(TranslationKeys.db_dbr061_msg_par1), fileName));
                    Log.OutputLine(MessageCodes.dbr062, $"{e.GetType().Name}: {e.Message}");

                    Match match = Regex.Match(e.Message, @"Failed to resolve\s+(?<name>[^\s]+)");

                    if (match.Success)
                    {
                        string name = match.Groups["name"].Value;

                        Log.OutputLine(MessageCodes.dbr063, string.Format(Translations.GetTranslationOfKey(TranslationKeys.db_dbr063_msg_par1), name));

                        this.LogMappings(name);

                        Log.OutputLine(MessageCodes.dbr064, Translations.GetTranslationOfKey(TranslationKeys.db_hint_skiptype));
                    }
                }
            }

            TypeNameCache.nameCache.Clear();
        }

        private string? DetermineSignToolExePath()
        {
            string? path = this.Project.Settings.SignToolExe;

            if (string.IsNullOrEmpty(path))
            {
                string programFilesX86Folder = Environment.GetFolderPath(Environment.SpecialFolder.ProgramFilesX86);

                string windows10SdkFolder = Path.Combine(programFilesX86Folder, @"Windows Kits\10\bin");

                string[] windows10KitVersionFolders = Directory.GetDirectories(windows10SdkFolder, "10.*");



                string? highestWindows10KitSignToolExe = windows10KitVersionFolders.Select(p => Path.Combine(p, "x64", "signtool.exe"))
                                                                                   .Where(File.Exists)
                                                                                   .OrderByDescending(x => x)
                                                                                   .FirstOrDefault()
                                                                                   ;

                path = highestWindows10KitSignToolExe;
            }

            return path;
        }

        private bool IsOnWindows 
        {
            get 
            {
                // https://stackoverflow.com/a/38795621/11182
                string? windir = Environment.GetEnvironmentVariable("windir");
                return !string.IsNullOrEmpty(windir) && windir.Contains(@"\") && Directory.Exists(windir);
            }
        }

        private void LogMappings(string name)
        {
            foreach ((TypeKey key, string statusText) in this.Mapping.FindClasses(name))
            {
                Log.Output(MessageCodes.dbr065, "{key.Fullname} => {statusText}");
            }
        }

        /// <summary>
        /// Saves the name mapping to the output path.
        /// </summary>
        private void SaveMapping()
        {
            string filename = this.Project.Settings.XmlMapping ? "Mapping.xml" : "Mapping.txt";

            string logFilePath = Path.Combine(this.Project.Settings.OutPath, filename);

            if (!string.IsNullOrEmpty(this.Project.Settings.LogFilePath))
            {
                logFilePath = this.Project.Settings.LogFilePath;
            }

            string? logDirectoryPath = Path.GetDirectoryName(logFilePath);

            if (!string.IsNullOrEmpty(logDirectoryPath) && !Directory.Exists(logDirectoryPath))
            {
                Directory.CreateDirectory(logDirectoryPath);
            }

            Log.OutputLine(MessageCodes.dbr057, string.Format(Translations.GetTranslationOfKey(TranslationKeys.db_dbr057_msg_par1), logFilePath));

            using (TextWriter file = File.CreateText(logFilePath))
            {
                this.SaveMapping(file);
            }
        }

        /// <summary>
        /// Saves the name mapping to a text writer.
        /// </summary>
        private void SaveMapping(TextWriter writer)
        {
            IMapWriter mapWriter = this.Project.Settings.XmlMapping ? new XmlMapWriter(writer) : new TextMapWriter(writer);

            mapWriter.WriteMap(this.Mapping);
        }

        /// <summary>
        /// Returns the obfuscation map for the project.
        /// </summary>
        internal ObfuscationMap Mapping { get; private set; }

        /// <summary>
        /// Calls the SemanticsAttributes-getter for all methods
        /// </summary>
        private void LoadMethodSemantics()
        {
            foreach (AssemblyInfo info in this.Project.AssemblyList)
            {
                foreach (TypeDefinition type in info.GetAllTypeDefinitions())
                {
                    foreach (MethodDefinition method in type.Methods)
                    {
                        string value = method.SemanticsAttributes.ToString();
                    }
                }
            }
        }

        /// <summary>
        /// Renames fields in the project.
        /// </summary>
        private void RenameFields()
        {
            if (!this.Project.Settings.RenameFields)
            {
                Log.OutputLine(MessageCodes.dbr150, Translations.GetTranslationOfKey(TranslationKeys.db_not_rename_fields));

                return;
            }
            else
            {
                Log.OutputLine(MessageCodes.dbr047, Translations.GetTranslationOfKey(TranslationKeys.db_rename_fields));

                foreach (AssemblyInfo info in this.Project.AssemblyList)
                {
                    //
                    // Loop through the types.
                    //
                    foreach (TypeDefinition type in info.GetAllTypeDefinitions())
                    {
                        if (type.FullName == Obfuscator.AutoGeneratedModuleName)
                        {
                            continue;
                        }

                        TypeKey typeKey = new TypeKey(type);
                        Dictionary<string, NameGroup> nameGroups = new Dictionary<string, NameGroup>();

                        //
                        // Rename field, grouping according to signature.
                        //
                        foreach (FieldDefinition field in type.Fields)
                        {
                            this.ProcessField(field, typeKey, nameGroups, info);
                        }
                    }
                }
            }
        }

        private void ProcessField(FieldDefinition field, TypeKey typeKey, Dictionary<string, NameGroup> nameGroups, AssemblyInfo info)
        {
            string sig = field.FieldType.FullName;
            FieldKey fieldKey = new FieldKey(typeKey, sig, field.Name, field);
            NameGroup nameGroup = this.GetNameGroup(nameGroups, sig);

            //
            // Skip filtered fields.
            //
            if (info.ShouldSkip(fieldKey, this.Project.InheritMap, this.Project.Settings.KeepPublicApi, this.Project.Settings.HidePrivateApi, this.Project.Settings.MarkedOnly, out string skip))
            {
                this.Mapping.UpdateField(fieldKey, ObfuscationStatus.Skipped, skip);
                nameGroup.Add(fieldKey.Name);
            }
            else
            {
                string newName = this.Project.Settings.ReuseNames ? nameGroup.GetNext() : NameMaker.UniqueName(this._uniqueMemberNameIndex++);

                this.RenameField(info, fieldKey, field, newName);
                nameGroup.Add(newName);
            }
        }

        private void RenameField(AssemblyInfo info, FieldKey fieldKey, FieldDefinition field, string newName)
        {
            //
            // Find references, rename them, then rename the field itself.
            //
            foreach (AssemblyInfo reference in info.ReferencedBy)
            {
                if (reference.UnrenamedReferences != null)
                {
                    for (int i = 0; i < reference.UnrenamedReferences.Count;)
                    {
                        FieldReference? member = reference.UnrenamedReferences[i] as FieldReference;

                        if (member != null)
                        {
                            if (fieldKey.Matches(member))
                            {
                                member.Name = newName;
                                reference.UnrenamedReferences.RemoveAt(i);

                                //
                                // Since we removed one, continue without the increment.
                                //
                                continue;
                            }
                        }

                        i++;
                    }
                }
            }

            field.Name = newName;
            this.Mapping.UpdateField(fieldKey, ObfuscationStatus.Renamed, newName);
        }

        /// <summary>
        /// Renames constructor, method, and generic parameters.
        /// </summary>
        private void RenameParameters()
        {
            Log.OutputLine(MessageCodes.dbr048, Translations.GetTranslationOfKey(TranslationKeys.db_rename_parameters));

            foreach (AssemblyInfo info in this.Project.AssemblyList)
            {
                //
                // Loop through the types.
                //
                foreach (TypeDefinition type in info.GetAllTypeDefinitions())
                {
                    if (type.FullName == Obfuscator.AutoGeneratedModuleName)
                    {
                        continue;
                    }

                    //
                    // Rename the method parameters.
                    //
                    foreach (MethodDefinition method in type.Methods)
                    {
                        this.RenameParams(method, info);
                    }

                    //
                    // Rename the class parameters.
                    //
                    if (info.ShouldSkip(new TypeKey(type), this.Project.InheritMap, this.Project.Settings.KeepPublicApi, this.Project.Settings.HidePrivateApi, this.Project.Settings.MarkedOnly, out string skip))
                    {
                        continue;
                    }

                    int index = 0;
                    foreach (GenericParameter param in type.GenericParameters)
                    {
                        param.Name = NameMaker.UniqueName(index++);
                    }
                }
            }
        }

        private void RenameParams(MethodDefinition method, AssemblyInfo info)
        {
            MethodKey methodkey = new MethodKey(method);

            if (info.ShouldSkipParams(methodkey, this.Project.InheritMap, this.Project.Settings.KeepPublicApi, this.Project.Settings.HidePrivateApi, this.Project.Settings.MarkedOnly, out string skip))
            {
                return;
            }

            foreach (ParameterDefinition param in method.Parameters)
            {
                if (param.CustomAttributes.Count == 0)
                {
                    param.Name = null;
                }
            }

            int index = 0;
            foreach (GenericParameter param in method.GenericParameters)
            {
                if (param.CustomAttributes.Count == 0)
                {
                    param.Name = NameMaker.UniqueName(index++);
                }
            }
        }

        /// <summary>
        /// Renames types and resources in the project.
        /// </summary>
        private void RenameTypes()
        {
            Log.OutputLine(MessageCodes.dbr054, string.Format(Translations.GetTranslationOfKey(TranslationKeys.db_dbr054_msg_par1), this.Project.AssemblyList.Count));

            foreach (AssemblyInfo info in this.Project.AssemblyList)
            {
                AssemblyDefinition? library = info.Definition;

                //
                // Make a list of the resources that can be renamed.
                //
                List<Resource> resources = new List<Resource>(library.MainModule.Resources);

                Dictionary<string, BamlDocument>? xamlFiles = info.XamlFiles;

                //
                // Save the original names of all types because parent (declaring) types of nested types may be already renamed.
                // The names are used for the mappings file.
                //
                Dictionary<TypeDefinition, TypeKey> unrenamedTypeKeys = info.GetAllTypeDefinitions().ToDictionary(type => type, type => new TypeKey(type));

                //
                // Loop through the types.
                //
                int typeIndex = 0;
                foreach (TypeDefinition type in info.GetAllTypeDefinitions())
                {
                    if (type.FullName == Obfuscator.AutoGeneratedModuleName)
                    {
                        continue;
                    }

                    if (type.FullName.IndexOf("<PrivateImplementationDetails>{", StringComparison.Ordinal) >= 0)
                    {
                        continue;
                    }

                    TypeKey oldTypeKey = new TypeKey(type);
                    TypeKey unrenamedTypeKey = unrenamedTypeKeys[type];
                    string fullName = type.FullName;

                    if (info.ShouldSkip(unrenamedTypeKey, this.Project.InheritMap, this.Project.Settings.KeepPublicApi, this.Project.Settings.HidePrivateApi, this.Project.Settings.MarkedOnly, out string skip))
                    {
                        this.Mapping.UpdateType(oldTypeKey, ObfuscationStatus.Skipped, skip);

                        //
                        // Go through the list of resources, remove ones that would be renamed.
                        //
                        for (int i = 0; i < resources.Count;)
                        {
                            Resource res = resources[i];
                            string resName = res.Name;

                            if (Path.GetFileNameWithoutExtension(resName) == fullName)
                            {
                                resources.RemoveAt(i);
                                this.Mapping.AddResource(resName, ObfuscationStatus.Skipped, skip);
                            }
                            else
                            {
                                i++;
                            }
                        }
                    }
                    else if (xamlFiles?.ContainsKey(type.FullName) ?? false)
                    {
                        this.Mapping.UpdateType(oldTypeKey, ObfuscationStatus.Skipped, "filtered by BAML");

                        //
                        // Go through the list of resources, remove ones that would be renamed.
                        //
                        for (int i = 0; i < resources.Count;)
                        {
                            Resource res = resources[i];
                            string resName = res.Name;

                            if (Path.GetFileNameWithoutExtension(resName) == fullName)
                            {
                                resources.RemoveAt(i);

                                this.Mapping.AddResource(resName, ObfuscationStatus.Skipped, "filtered by BAML");
                            }
                            else
                            {
                                i++;
                            }
                        }
                    }
                    else
                    {
                        string name;
                        string ns;
                        if (type.IsNested)
                        {
                            ns = string.Empty;

                            if (type.DeclaringType != null)
                            {
                                name = NameMaker.UniqueNestedTypeName(type.DeclaringType.NestedTypes.IndexOf(type));
                            }
                            else
                            {
                                name = string.Empty;
                            }
                        }
                        else
                        {
                            if (this.Project.Settings.ReuseNames)
                            {
                                name = NameMaker.UniqueTypeName(typeIndex);
                                ns = NameMaker.UniqueNamespace(typeIndex);
                            }
                            else
                            {
                                name = NameMaker.UniqueName(this._uniqueTypeNameIndex);
                                ns = NameMaker.UniqueNamespace(this._uniqueTypeNameIndex);
                                this._uniqueTypeNameIndex++;
                            }
                        }

                        if (type.GenericParameters.Count > 0)
                        {
                            name += '`' + type.GenericParameters.Count.ToString();
                        }

                        if (type.DeclaringType != null)
                        {
                            ns = string.Empty; // Nested types do not have namespaces
                        }

                        TypeKey newTypeKey = new TypeKey(info.Name, ns, name);
                        typeIndex++;

                        this.FixResouceManager(resources, type, fullName, newTypeKey);

                        this.RenameType(info, type, oldTypeKey, newTypeKey, unrenamedTypeKey);
                    }
                }

                foreach (Resource res in resources)
                {
                    this.Mapping.AddResource(res.Name, ObfuscationStatus.Skipped, "no clear new name");
                }

                info.InvalidateCache();
            }
        }

        private void FixResouceManager(List<Resource> resources, TypeDefinition type, string fullName,
            TypeKey newTypeKey)
        {
            if (!type.IsResourcesType())
            {
                return;
            }

            //
            // Go through the list of renamed types and try to rename resources.
            //
            for (int i = 0; i < resources.Count;)
            {
                Resource res = resources[i];
                string resName = res.Name;

                if (Path.GetFileNameWithoutExtension(resName) == fullName)
                {
                    //
                    // If one of the type's methods return a ResourceManager and contains a string with the full type name,
                    // we replace the type string with the obfuscated one.
                    // This is for the Visual Studio generated resource designer code.
                    //
                    foreach (MethodDefinition method in type.Methods)
                    {
                        if (method.ReturnType.FullName != "System.Resources.ResourceManager")
                        {
                            continue;
                        }

                        foreach (Instruction instruction in method.Body.Instructions)
                        {
                            if (instruction.OpCode == OpCodes.Ldstr && instruction.Operand is string operand && operand == fullName)
                            {
                                instruction.Operand = newTypeKey.Fullname;
                            }
                        }
                    }

                    if (!string.IsNullOrEmpty(fullName))
                    {
                        string suffix = resName.Substring(fullName.Length);
                        string newName = newTypeKey.Fullname + suffix;
                        res.Name = newName;
                        resources.RemoveAt(i);

                        this.Mapping.AddResource(resName, ObfuscationStatus.Renamed, newName);
                    }
                    else
                    {
                        throw new ObfuscarException(MessageCodes.dbr023, Translations.GetTranslationOfKey(TranslationKeys.db_full_name_missing));
                    }
                }
                else
                {
                    i++;
                }
            }
        }

        private void RenameType(AssemblyInfo info, TypeDefinition type, TypeKey oldTypeKey, TypeKey newTypeKey, TypeKey unrenamedTypeKey)
        {
            //
            // Find references, rename them, then rename the type itself.
            //
            foreach (AssemblyInfo reference in info.ReferencedBy)
            {
                if (reference.UnrenamedTypeReferences != null)
                {
                    for (int i = 0; i < reference.UnrenamedTypeReferences.Count;)
                    {
                        TypeReference refType = reference.UnrenamedTypeReferences[i];

                        //
                        // Check whether the referencing module references this type...if so,
                        // rename the reference.
                        //
                        if (oldTypeKey.Matches(refType))
                        {
                            refType.GetElementType().Namespace = newTypeKey.Namespace;
                            refType.GetElementType().Name = newTypeKey.Name;

                            reference.UnrenamedTypeReferences.RemoveAt(i);

                            //
                            // Since we removed one, continue without the increment.
                            //
                            continue;
                        }

                        i++;
                    }
                }
            }

            type.Namespace = newTypeKey.Namespace;
            type.Name = newTypeKey.Name;

            this.Mapping.UpdateType(unrenamedTypeKey, ObfuscationStatus.Renamed, $"[{newTypeKey.Scope}]{type}");
        }

        private Dictionary<ParamSig, NameGroup> GetSigNames(Dictionary<TypeKey, Dictionary<ParamSig, NameGroup>> baseSigNames, TypeKey typeKey)
        {
            if (!baseSigNames.TryGetValue(typeKey, out Dictionary<ParamSig, NameGroup>? sigNames))
            {
                sigNames = new Dictionary<ParamSig, NameGroup>();
                baseSigNames[typeKey] = sigNames;
            }

            return sigNames;
        }

        private NameGroup GetNameGroup(Dictionary<TypeKey, Dictionary<ParamSig, NameGroup>> baseSigNames, TypeKey typeKey, ParamSig sig)
        {
            return this.GetNameGroup(this.GetSigNames(baseSigNames, typeKey), sig);
        }

        private NameGroup GetNameGroup<TKeyType>(Dictionary<TKeyType, NameGroup> sigNames, TKeyType sig) where TKeyType : notnull
        {
            if (!sigNames.TryGetValue(sig, out NameGroup? nameGroup))
            {
                nameGroup = new NameGroup();
                sigNames[sig] = nameGroup;
            }

            return nameGroup;
        }

        /// <summary>
        /// Rename properties.
        /// </summary>
        private void RenameProperties()
        {
            //
            // Do nothing if it was requested not to rename.
            //
            if (!this.Project.Settings.RenameProperties)
            {
                Log.OutputLine(MessageCodes.dbr151, Translations.GetTranslationOfKey(TranslationKeys.db_not_rename_properties));

                return;
            }
            else
            {
                Log.OutputLine(MessageCodes.dbr049, Translations.GetTranslationOfKey(TranslationKeys.db_rename_properties));

                foreach (AssemblyInfo info in this.Project.AssemblyList)
                {
                    foreach (TypeDefinition type in info.GetAllTypeDefinitions())
                    {
                        if (type.FullName == Obfuscator.AutoGeneratedModuleName)
                        {
                            continue;
                        }

                        TypeKey typeKey = new TypeKey(type);

                        int index = 0;
                        List<PropertyDefinition> propsToDrop = new List<PropertyDefinition>();

                        foreach (PropertyDefinition prop in type.Properties)
                        {
                            index = this.ProcessProperty(typeKey, prop, info, type, index, propsToDrop);
                        }

                        foreach (PropertyDefinition prop in propsToDrop)
                        {
                            PropertyKey propKey = new PropertyKey(typeKey, prop);
                            ObfuscatedThing m = this.Mapping.GetProperty(propKey);
                            m.Update(ObfuscationStatus.Renamed, "dropped");
                            type.Properties.Remove(prop);
                        }
                    }
                }
            }
        }

        private int ProcessProperty(TypeKey typeKey, PropertyDefinition prop, AssemblyInfo info, TypeDefinition type, int index, List<PropertyDefinition> propsToDrop)
        {
            PropertyKey propKey = new PropertyKey(typeKey, prop);
            ObfuscatedThing m = this.Mapping.GetProperty(propKey);

            string skip;

            //
            // Skip filtered props.
            //
            if (info.ShouldSkip(propKey, this.Project.InheritMap, this.Project.Settings.KeepPublicApi, this.Project.Settings.HidePrivateApi, this.Project.Settings.MarkedOnly, out skip))
            {
                m.Update(ObfuscationStatus.Skipped, skip);

                //
                // Make sure get/set get skipped too.
                //
                if (prop.GetMethod != null)
                {
                    this.ForceSkip(prop.GetMethod, "skip by property");
                }

                if (prop.SetMethod != null)
                {
                    this.ForceSkip(prop.SetMethod, "skip by property");
                }

                return index;
            }

            if (type.BaseType != null && type.BaseType.Name.EndsWith("Attribute") && prop.SetMethod != null && (prop.SetMethod.Attributes & MethodAttributes.Public) != 0)
            {
                //
                // Do not rename properties of custom attribute types which have a public setter method.
                //
                m.Update(ObfuscationStatus.Skipped, "public setter of a custom attribute");
                //
                // No problem when the getter or setter methods are renamed by RenameMethods().
                //
            }
            else if (prop.CustomAttributes.Count > 0)
            {
                //
                // If a property has custom attributes we don't remove the property but rename it instead.
                //
                string newName = NameMaker.UniqueName(this.Project.Settings.ReuseNames ? index++ : this._uniqueMemberNameIndex++);
                this.RenameProperty(info, propKey, prop, newName);
            }
            else
            {
                //
                // Add to to collection for removal.
                //
                propsToDrop.Add(prop);
            }
            return index;
        }

        private void RenameProperty(AssemblyInfo info, PropertyKey propertyKey, PropertyDefinition property, string newName)
        {
            //
            // Find references, rename them, then rename the property itself.
            //
            foreach (AssemblyInfo reference in info.ReferencedBy)
            {
                if (reference.UnrenamedReferences != null)
                {
                    for (int i = 0; i < reference.UnrenamedReferences.Count;)
                    {
                        if (reference.UnrenamedReferences[i] is PropertyReference member)
                        {
                            if (propertyKey.Matches(member))
                            {
                                member.Name = newName;
                                reference.UnrenamedReferences.RemoveAt(i);

                                //
                                // Since we removed one, continue without the increment.
                                //
                                continue;
                            }
                        }

                        i++;
                    }
                }
            }

            property.Name = newName;
            this.Mapping.UpdateProperty(propertyKey, ObfuscationStatus.Renamed, newName);
        }

        /// <summary>
        /// Rename events.
        /// </summary>
        private void RenameEvents()
        {
            //
            // Do nothing if it was requested not to rename.
            //
            if (!this.Project.Settings.RenameEvents)
            {
                Log.OutputLine(MessageCodes.dbr050, Translations.GetTranslationOfKey(TranslationKeys.db_not_rename_events));

                return;
            }
            else
            {
                Log.OutputLine(MessageCodes.dbr152, Translations.GetTranslationOfKey(TranslationKeys.db_rename_events));

                foreach (AssemblyInfo info in this.Project.AssemblyList)
                {
                    foreach (TypeDefinition type in info.GetAllTypeDefinitions())
                    {
                        if (type.FullName == Obfuscator.AutoGeneratedModuleName)
                        {
                            continue;
                        }

                        TypeKey typeKey = new TypeKey(type);
                        List<EventDefinition> evtsToDrop = new List<EventDefinition>();
                        foreach (EventDefinition evt in type.Events)
                        {
                            this.ProcessEvent(typeKey, evt, info, evtsToDrop);
                        }

                        foreach (EventDefinition evt in evtsToDrop)
                        {
                            EventKey evtKey = new EventKey(typeKey, evt);
                            ObfuscatedThing m = this.Mapping.GetEvent(evtKey);

                            m.Update(ObfuscationStatus.Renamed, "dropped");
                            type.Events.Remove(evt);
                        }
                    }
                }
            }
        }

        private void ProcessEvent(TypeKey typeKey, EventDefinition evt, AssemblyInfo info, List<EventDefinition> evtsToDrop)
        {
            EventKey evtKey = new EventKey(typeKey, evt);
            ObfuscatedThing m = this.Mapping.GetEvent(evtKey);

            //
            // Skip filtered events.
            //
            if (info.ShouldSkip(evtKey, this.Project.InheritMap, this.Project.Settings.KeepPublicApi,
                this.Project.Settings.HidePrivateApi,
                this.Project.Settings.MarkedOnly, out string skip))
            {
                m.Update(ObfuscationStatus.Skipped, skip);

                //
                // Make sure add/remove get skipped too.
                //
                this.ForceSkip(evt.AddMethod, "skip by event");
                this.ForceSkip(evt.RemoveMethod, "skip by event");
                return;
            }

            //
            // Add to to collection for removal.
            //
            evtsToDrop.Add(evt);
        }

        private void ForceSkip(MethodDefinition method, string skip)
        {
            ObfuscatedThing delete = this.Mapping.GetMethod(new MethodKey(method));
            delete.Status = ObfuscationStatus.Skipped;
            delete.StatusText = skip;
        }

        /// <summary>
        /// Rename methods.
        /// </summary>
        private void RenameMethods()
        {
            Log.OutputLine(MessageCodes.dbr051, Translations.GetTranslationOfKey(TranslationKeys.db_rename_methods));

            Dictionary<TypeKey, Dictionary<ParamSig, NameGroup>> baseSigNames = new Dictionary<TypeKey, Dictionary<ParamSig, NameGroup>>();
            foreach (AssemblyInfo info in this.Project.AssemblyList)
            {
                foreach (TypeDefinition type in info.GetAllTypeDefinitions())
                {
                    if (type.FullName == Obfuscator.AutoGeneratedModuleName)
                    {
                        continue;
                    }

                    TypeKey typeKey = new TypeKey(type);

                    Dictionary<ParamSig, NameGroup> sigNames = this.GetSigNames(baseSigNames, typeKey);

                    //
                    // First pass.  mark grouped virtual methods to be renamed, and mark some things
                    // to be skipped as neccessary.
                    //
                    foreach (MethodDefinition method in type.Methods)
                    {
                        this.ProcessMethod(typeKey, method, info, baseSigNames);
                    }

                    //
                    // Update name groups, so new names don't step on inherited ones.
                    //
                    if (this.Project.InheritMap != null)
                    {
                        foreach (TypeKey baseType in this.Project.InheritMap.GetBaseTypes(typeKey))
                        {
                            Dictionary<ParamSig, NameGroup> baseNames = this.GetSigNames(baseSigNames, baseType);
                            foreach (KeyValuePair<ParamSig, NameGroup> pair in baseNames)
                            {
                                NameGroup nameGroup = this.GetNameGroup(sigNames, pair.Key);
                                nameGroup.AddAll(pair.Value);
                            }
                        }
                    }
                }

                foreach (TypeDefinition type in info.GetAllTypeDefinitions())
                {
                    if (type.FullName == Obfuscator.AutoGeneratedModuleName)
                    {
                        continue;
                    }

                    TypeKey typeKey = new TypeKey(type);
                    Dictionary<ParamSig, NameGroup> sigNames = this.GetSigNames(baseSigNames, typeKey);

                    //
                    // Second pass...marked virtuals and anything not skipped get renamed.
                    //
                    foreach (MethodDefinition method in type.Methods)
                    {
                        MethodKey methodKey = new MethodKey(typeKey, method);
                        ObfuscatedThing m = this.Mapping.GetMethod(methodKey);

                        //
                        // If we already decided to skip it, leave it alone.
                        //
                        if (m.Status == ObfuscationStatus.Skipped)
                        {
                            continue;
                        }

                        if (method.IsSpecialName)
                        {
                            switch (method.SemanticsAttributes)
                            {
                                case MethodSemanticsAttributes.Getter:
                                case MethodSemanticsAttributes.Setter:
                                    {
                                        if (this.Project.Settings.RenameProperties)
                                        {
                                            this.RenameMethod(info, sigNames, methodKey, method);
                                            method.SemanticsAttributes = 0;
                                        }
                                        break;
                                    }
                                case MethodSemanticsAttributes.AddOn:
                                case MethodSemanticsAttributes.RemoveOn:
                                    {
                                        if (this.Project.Settings.RenameEvents)
                                        {
                                            this.RenameMethod(info, sigNames, methodKey, method);
                                            method.SemanticsAttributes = 0;
                                        }
                                        break;
                                    }
                            }
                        }
                        else
                        {
                            this.RenameMethod(info, sigNames, methodKey, method);
                        }
                    }
                }
            }
        }

        private void ProcessMethod(TypeKey typeKey, MethodDefinition method, AssemblyInfo info, Dictionary<TypeKey, Dictionary<ParamSig, NameGroup>> baseSigNames)
        {
            MethodKey methodKey = new MethodKey(typeKey, method);
            ObfuscatedThing m = this.Mapping.GetMethod(methodKey);

            if (m.Status == ObfuscationStatus.Skipped)
            {
                //
                // IMPORTANT: shortcut for event and property methods.
                //
                return;
            }

            //
            // Skip filtered methods.
            //
            bool toDo = info.ShouldSkip(methodKey, this.Project.InheritMap, this.Project.Settings.KeepPublicApi, this.Project.Settings.HidePrivateApi, this.Project.Settings.MarkedOnly, out string? skiprename);

            if (!toDo)
            {
                skiprename = null;
            }
            //
            // Update status for skipped non-virtual methods immediately...status for
            // skipped virtual methods gets updated in RenameVirtualMethod.
            //
            if (!method.IsVirtual)
            {
                if (skiprename != null)
                {
                    m.Update(ObfuscationStatus.Skipped, skiprename);
                }

                return;
            }

            //
            // If we need to skip the method or we don't yet have a name planned for a method, rename it.
            //
            if ((skiprename != null && m.Status != ObfuscationStatus.Skipped) || m.Status == ObfuscationStatus.Unknown)
            {
                this.RenameVirtualMethod(baseSigNames, methodKey, method, skiprename);
            }
        }

        private void RenameVirtualMethod(Dictionary<TypeKey, Dictionary<ParamSig, NameGroup>> baseSigNames, MethodKey methodKey, MethodDefinition method, string? skipRename)
        {
            //
            // If method is in a group, look for group key.
            //
            MethodGroup? group = this.Project.InheritMap?.GetMethodGroup(methodKey);

            if (group == null)
            {
                if (skipRename != null)
                {
                    this.Mapping.UpdateMethod(methodKey, ObfuscationStatus.Skipped, skipRename);
                }

                return;
            }

            string? groupName = group.Name;

            if (groupName == null)
            {
                //
                // Group is not yet named.
                //
                // Counts are grouping according to signature.
                //
                ParamSig sig = new ParamSig(method);

                //
                // Get name groups for classes in the group.
                //
                NameGroup[] nameGroups = this.GetNameGroups(baseSigNames, group.Methods, sig);

                if (group.External)
                {
                    skipRename = "external base class or interface";
                }

                if (skipRename != null)
                {
                    //
                    // For an external group, we can't rename. Just use the method
                    // name as group name.
                    //
                    groupName = method.Name;
                }
                else
                {
                    //
                    // For an internal group, get next unused name.
                    //
                    groupName = NameGroup.GetNext(nameGroups);
                }

                group.Name = groupName;

                // set up methods to be renamed
                foreach (MethodKey m in group.Methods)
                {
                    if (skipRename == null)
                    {
                        this.Mapping.UpdateMethod(m, ObfuscationStatus.WillRename, groupName);
                    }
                    else
                    {
                        this.Mapping.UpdateMethod(m, ObfuscationStatus.Skipped, skipRename);
                    }
                }

                //
                // Make sure the classes' name groups are updated.
                //
                foreach (NameGroup t in nameGroups)
                {
                    t.Add(groupName);
                }
            }
            else if (skipRename != null)
            {
                //
                // Group is named, so we need to un-name it.
                //
                if (group.External)
                {
                    throw new ObfuscarException
                    ( MessageCodes.dbr143
                    , Translations.GetTranslationOfKey(TranslationKeys.db_dbr143_msg)
                    );
                }

                this.Mapping.UpdateMethod(methodKey, ObfuscationStatus.Skipped, skipRename);

                StringBuilder message = new StringBuilder("Inconsistent virtual method obfuscation state detected. Abort. Please review the following methods,").AppendLine();
                foreach (MethodKey item in group.Methods)
                {
                    ObfuscatedThing state = this.Mapping.GetMethod(item);
                    message.AppendFormat("{0}->{1}:{2}", item, state.Status, state.StatusText).AppendLine();
                }

                throw new ObfuscarException(MessageCodes.dbr016, message.ToString());
            }
            else
            {
                ObfuscatedThing m = this.Mapping.GetMethod(methodKey);
                if (!(m.Status == ObfuscationStatus.Skipped || ((m.Status == ObfuscationStatus.WillRename || m.Status == ObfuscationStatus.Renamed) && m.StatusText == groupName)))
                {
                    throw new ObfuscarException(MessageCodes.dbr144, Translations.GetTranslationOfKey(TranslationKeys.db_dbr144_msg));
                }
            }
        }

        NameGroup[] GetNameGroups(Dictionary<TypeKey, Dictionary<ParamSig, NameGroup>> baseSigNames, IEnumerable<MethodKey> methodKeys, ParamSig sig)
        {
            //
            // Build unique set of classes in group.
            //
            HashSet<TypeKey> typeKeys = new HashSet<TypeKey>();
            foreach (MethodKey methodKey in methodKeys)
            {
                typeKeys.Add(methodKey.TypeKey);
            }

            HashSet<TypeKey> parentTypes = new HashSet<TypeKey>();

            foreach (TypeKey type in typeKeys)
            {
                if (type.TypeDefinition != null)
                {
                    InheritMap.GetBaseTypes(this.Project, parentTypes, type.TypeDefinition);
                }
            }

            typeKeys.UnionWith(parentTypes);

            //
            // Build list of namegroups.
            //
            NameGroup[] nameGroups = new NameGroup[typeKeys.Count];

            int i = 0;
            foreach (TypeKey typeKey in typeKeys)
            {
                NameGroup nameGroup = this.GetNameGroup(baseSigNames, typeKey, sig);

                nameGroups[i++] = nameGroup;
            }

            return nameGroups;
        }

        private string? GetNewMethodName(Dictionary<ParamSig, NameGroup> sigNames, MethodKey methodKey, MethodDefinition method)
        {
            ObfuscatedThing t = this.Mapping.GetMethod(methodKey);

            //
            // If it already has a name, return it.
            //
            if (t.Status == ObfuscationStatus.Renamed || t.Status == ObfuscationStatus.WillRename)
            {
                return t.StatusText;
            }

            //
            // Don't mess with methods we decided to skip.
            //
            if (t.Status == ObfuscationStatus.Skipped)
            {
                return null;
            }

            //
            // Got a new name for the method.
            //
            t.Status = ObfuscationStatus.WillRename;
            t.StatusText = this.GetNewName(sigNames, method);

            return t.StatusText;
        }

        private string GetNewName(Dictionary<ParamSig, NameGroup> sigNames, MethodDefinition method)
        {
            //
            // Counts are grouping according to signature.
            //
            ParamSig sig = new ParamSig(method);

            NameGroup nameGroup = this.GetNameGroup(sigNames, sig);

            string newName = nameGroup.GetNext();

            //
            // Make sure the name groups is updated.
            //
            nameGroup.Add(newName);

            return newName;
        }

        private void RenameMethod(AssemblyInfo info, Dictionary<ParamSig, NameGroup> sigNames, MethodKey methodKey, MethodDefinition method)
        {
            string? newName = this.GetNewMethodName(sigNames, methodKey, method);

            if (newName != null)
            {
                this.RenameMethod(info, methodKey, method, newName);
            }
        }

        private void RenameMethod(AssemblyInfo info, MethodKey methodKey, MethodDefinition method, string newName)
        {
            //
            // Find references, rename them, then rename the method itself.
            //
            List<AssemblyInfo> references = new List<AssemblyInfo>(info.ReferencedBy);

            if (!references.Contains(info))
            {
                references.Add(info);
            }

            List<GenericInstanceMethod> generics = new List<GenericInstanceMethod>();

            //
            // Rename references.
            //
            foreach (AssemblyInfo reference in references)
            {
                if (reference.UnrenamedReferences != null)
                {
                    for (int i = 0; i < reference.UnrenamedReferences.Count;)
                    {
                        if (reference.UnrenamedReferences[i] is MethodReference member)
                        {
                            if (methodKey.Matches(member))
                            {
                                if (member is GenericInstanceMethod generic)
                                {
                                    generics.Add(generic);
                                }
                                else
                                {
                                    member.Name = newName;
                                }

                                reference.UnrenamedReferences.RemoveAt(i);

                                //
                                // Since we removed one, continue without the increment.
                                //
                                continue;
                            }
                        }

                        i++;
                    }
                }
            }

            //
            // Rename generic methods.
            //
            foreach (GenericInstanceMethod generic in generics)
            {
                generic.ElementMethod.Name = newName;
            }

            method.Name = newName;

            this.Mapping.UpdateMethod(methodKey, ObfuscationStatus.Renamed, newName);
        }

        /// <summary>
        /// Encoded strings using an auto-generated class.
        /// </summary>
        private void HideStrings()
        {
            foreach (AssemblyInfo info in this.Project.AssemblyList)
            {
                AssemblyDefinition? library = info.Definition;
                StringSqueeze container = new StringSqueeze(library);

                //
                // Look for all string load operations and replace them with calls to indiviual methods in our new class.
                //
                foreach (TypeDefinition type in info.GetAllTypeDefinitions())
                {
                    if (type.FullName == Obfuscator.AutoGeneratedModuleName)
                    {
                        continue;
                    }

                    //
                    // FIXME: Figure out why this exists if it is never used.
                    // TypeKey typeKey = new TypeKey(type);
                    //
                    foreach (MethodDefinition method in type.Methods)
                    {
                        container.ProcessStrings(method, info, this.Project);
                    }
                }

                container.Squeeze();
            }
        }

        /// <summary>
        /// Do post processing actions.
        /// </summary>
        private void PostProcessing()
        {
            Log.OutputLine(MessageCodes.dbr055, string.Format(Translations.GetTranslationOfKey(TranslationKeys.db_dbr055_msg_par1), this.Project.AssemblyList.Count));

            foreach (AssemblyInfo info in this.Project.AssemblyList)
            {
                info.Definition.CleanAttributes();
                foreach (TypeDefinition type in info.GetAllTypeDefinitions())
                {
                    if (type.FullName == Obfuscator.AutoGeneratedModuleName)
                    {
                        continue;
                    }

                    type.CleanAttributes();

                    foreach (FieldDefinition? field in type.Fields)
                    {
                        field.CleanAttributes();
                    }

                    foreach (PropertyDefinition? property in type.Properties)
                    {
                        property.CleanAttributes();
                    }

                    foreach (EventDefinition? eventItem in type.Events)
                    {
                        eventItem.CleanAttributes();
                    }

                    //
                    // First pass. Mark grouped virtual methods to be renamed, and mark some things
                    // to be skipped as neccessary.
                    //
                    foreach (MethodDefinition method in type.Methods)
                    {
                        method.CleanAttributes();
                        if (method.HasBody && this.Project.Settings.OptimizeMethods)
                        {
                            method.Body.Optimize();
                        }
                    }
                }

                if (!this.Project.Settings.SuppressIldasm)
                {
                    continue;
                }

                ModuleDefinition module = info.Definition.MainModule;
                TypeDefinition attribute = new TypeReference("System.Runtime.CompilerServices", "SuppressIldasmAttribute", module, module.TypeSystem.CoreLibrary).Resolve();
                if (attribute == null || attribute.Module != module.TypeSystem.CoreLibrary)
                {
                    return;
                }

                CustomAttribute? found = module.CustomAttributes.FirstOrDefault(existing => existing.Constructor.DeclaringType.FullName == attribute.FullName);

                //
                // Only add if it's not there already.
                //
                if (found != null)
                {
                    continue;
                }

                //
                // Add one.
                //
                MethodReference add = module.ImportReference(attribute.GetConstructors().FirstOrDefault(item => !item.HasParameters));
                MethodReference constructor = module.ImportReference(add);
                CustomAttribute attr = new CustomAttribute(constructor);
                module.CustomAttributes.Add(attr);
                module.Assembly.CustomAttributes.Add(attr);
            }
        }
    }
}
